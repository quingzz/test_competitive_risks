{
  "hash": "64c7d3c9d0be04eca7ed8985b00f3349",
  "result": {
    "markdown": "---\ntoc: true\ntitle: \"Test competing risks\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\n#   \"odin2\",\n#   repos = c(\"https://mrc-ide.r-universe.dev\", \"https://cloud.r-project.org\"))\nlibrary(odin2)\nlibrary(dust2)\nlibrary(deSolve)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(dplyr)\n```\n:::\n\n\n# Proposed formulation\n\n[New formulation](https://choisy.github.io/competing_risks/competitive%20waiting%20times.html)\n\nConsider a XYZW model where:\n\n-   Y-\\>Z and Y-\\>W are competitive risks\n\n-   Maximum wait time for Y-\\>Z (Y-\\>W) is n (m)\n\n-   $n \\geq m$ (maximum dwell time of Y-\\>Z is greater than that of Y-\\>W)\n\nNew probability distribution for Y\n\n$$\nb_i = \\frac{z' p_i + (1 - z) q_i}{\\sum^m_j(z'p_j + (1-z)q_j)}\n$$\n\nWhere\n\n-   z is the proportion of people that ends up in Z [at equilibrium]{.underline} $z = \\frac{Z}{Z + W}$\n\n-   z' is the proportion of people that ultimately ending up in Z and stays in Y up to m time steps. $$\n    z' = z\\frac{\\sum_{j=1}^m  p_j}{\\sum_{k=1}^n p_k}\n    $$\n\n::: {.callout-note collapse=\"TRUE\"}\n## Adjustment for z' formulation\n\nz' originally defined as $z' = \\frac{\\sum_{j=1}^m zp_j}{\\sum_{k=1}^n zp_k} = \\frac{\\sum_{j=1}^m p_j}{\\sum_{k=1}^n p_k}$\n\nWhich is the proportion of people that stays in Y up to m steps, given that they transitioned to Z (i.e. $P(\\text{dwell time} \\leq m |Z)$ while we need $P(\\text{dwell time} \\leq m,Z)$\n:::\n\n::: {.callout-important collapse=\"TRUE\"}\n## Issue with current formulation for $b_i$\n\nBy normalizing $b_i$ (divide by $\\sum^m_j(z'p_j + (1-z)q_j)$), $\\sum^{m}_{j=1}b_j$ is equal to 1 which means $\\sum^{n}_{j=1}b_j \\geq 1$\n\nWhile sum of the dwell time distribution must be 1\n\n**Adjustment:** test both scenarios where normalization (@sec-normalize) is applied and is not applied (@sec-no-normalize)\n:::\n\nOutgoing rate from $Y_i$ to $Y_{i+1}$ is then computed by\n\n$$\n1 - \\sum_{j=1}^i {b_j}\n$$\n\nOutgoing rate from $Y_i$ to Z and W is\n$$\n\\delta_i =  \\frac{b_i}{1 - \\sum_{j=1}^{i-1} {b_j}}\n$$\nWhere:\n\n- $\\frac{z'p_i}{z'p_i + (1-z)q_i} \\delta_i$ goes to Z.\n\n- $\\frac{(1-z)q_i}{z'p_i + (1-z)q_i} \\delta_i$ goes to W.\n\n\n::: {.callout-important collapse=\"true\"}\n## How the current formulation may equates to multinomial when n=m\n\nConsider the scenario where $n = m$\n\n$$\nb_i = \\frac{zp_i + (1-z)q_i}{\\sum_{j=1}^m(zp_j + (1-z)q_j)}\n$$ \n\nSince $\\sum(zp_j + (1-z)q_j)$ can be rewritten as $z\\sum p_j + (1-z)\\sum q_j$ which equates to 1 \n\n$$\nb_i = zp_i + (1-z)q_i\n$$\n\nOut transition from $Y_i$ to Z is then \n$$\n\\frac{zp_i}{zp_i + (1-z)q_i} * \\frac{b_i}{1 - \\sum_{j=1}^{i} b_j} \\\\\n= \\frac{zp_i}{b_i} * \\frac{b_i}{1 - \\sum_{j=1}^{i} b_j} \\\\\n= \\frac{zp_i}{1 - \\sum_{j=1}^{i} b_j}\n$$\nOut population from $Y_i$ to Z is then\n$$\nn_i*\\frac{zp_i}{1 - \\sum_{j=1}^{i-1} b_j}\n$$\n\nRecall that $n_i = n_{i-1}*(1 - \\sum_{j=1}^{i-1} b_j)$\n\nOutgoing population from $Y_i$ to Z can then be rewritten as \n\n$$\nn_{i-1}*z*p_i\n$$\nSimilarly, outgoing population population from $Y_i$ to W can be written as\n$$\nn_{i-1}*(1-z)*q_i\n$$\nWhich is equivalent to having 2 sub-compartment chains, one for $n_{i-1}*z$ and the other for $n_{i-1}*(1-z)$.\n:::\n\n# Model and helper functions\n\n## Model implemented in odin\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"proposed algo implemented in odin\"}\nsird_mod <- odin2::odin(\n  {\n    # equivalent to mathexpr in denim\n    update(S) <- S - dt * S * beta * sum(I) / N\n\n    update(I[1]) <- dt * S * beta* sum(I)/N\n    update(I[2:r_maxtime]) <- I[i-1]*(1-transprob[i-1])\n    \n    dim(I_to_R) <- r_maxtime\n    # equivalent to delta_i*z'*p_i/(z'*p_i + (1-z)*q_i)\n    I_to_R[1:r_maxtime] <- transprob[i]*I[i]*\n                           (p_prime*r_dist[i])/(p_prime*r_dist[i] + (1-r_prob)*d_dist[i])\n    sum_I_to_R <- sum(I_to_R)\n    update(R) <- R + sum_I_to_R\n    \n    dim(I_to_D) <- d_maxtime\n    # equivalent to delta_i*(1-z)*q_i/(z'*p_i + (1-z)*q_i)\n    I_to_D[1:d_maxtime] <- transprob[i]*I[i]*\n                           (d_prob*d_dist[i])/(p_prime*r_dist[i] + (1-r_prob)*d_dist[i])\n    sum_I_to_D <- sum(I_to_D)\n    update(D) <- D + sum_I_to_D\n    \n    # print(\"I to R {sum_I_to_R} I to D {sum_I_to_D}\")\n    \n    \n    # initial population\n    initial(S) <- S_init\n    initial(I[]) <- I_init[i]\n    dim(I) <- r_maxtime\n    initial(R) <- R_init\n    initial(D) <- D_init\n    \n    # ----- Inputs -------\n    beta <- parameter()\n    \n    # dwell time distribution of r \n    r_dist <- parameter()\n    r_maxtime <- parameter()\n    r_prob <- parameter(0.5) # proportion that end up in R at equilibrium\n    dim(r_dist) <- r_maxtime\n    \n    # dwell time distribution of d\n    d_dist <- parameter()\n    d_maxtime <- parameter()\n    d_prob <- parameter(0.5) # proportion that end up in D at equilibrium\n    dim(d_dist) <- d_maxtime\n    \n    # parameter to control whether to normalize i_dist\n    normalize_dist <- parameter(TRUE, type=\"logical\")\n    \n    # initial populations\n    S_init <- parameter()\n    I_init <- parameter()\n    dim(I_init) <-  r_maxtime\n    R_init <- parameter()\n    D_init <- parameter()\n    N <- parameter(1000)\n    \n    # ----- Compute out transition here --------\n    # assume dwell time of r >= dwell time of d\n    # i_dist is the new dwell time distribution in I\n    dim(i_dist) <- r_maxtime \n    \n    # prob of people that would end up in R and stay in I up to d_maxtime\n    # equivalent of z'\n    p_prime <- r_prob*sum(r_dist[1:d_maxtime])/sum(r_dist)\n    \n    \n    # distribution normalizer\n    dim(normalizer) <- d_maxtime\n    normalizer[] <- p_prime*r_dist[i] + (1-r_prob)*d_dist[i]\n\n    # Bug due to sum of i_dist end up greater than 1 when normalized\n    i_dist[1:d_maxtime] <- if (normalize_dist) (p_prime*r_dist[i] + d_prob*d_dist[i])/sum(normalizer) \n    else (p_prime*r_dist[i] + d_prob*d_dist[i])\n    # for i_dist at timestep > d_maxtime is just the probability distribution of I->R transition\n    i_dist[(d_maxtime+1):r_maxtime] <- r_dist[i]\n\n    # transition prob\n    dim(transprob) <- r_maxtime\n    transprob[1] <- i_dist[i]\n    transprob[2:r_maxtime] <- i_dist[i]/(1 - sum(i_dist[1:(i-1)]))\n    \n    # browser(phase = \"update\", when = time<1)\n  }\n)\n```\n:::\n\n\n## Helper functions\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Function to compute transition probability\"}\ncompute_trans_prob <- function(rate, timestep=0.05, error_tolerance=0.0001){\n  maxtime <- timestep\n  prev_prob <- 0\n  transprob <- numeric()\n  cumulative_dist <- numeric()\n  prob_dist <- numeric()\n  \n  while(TRUE){\n     # get current cumulative prob \n     temp_prob <-  if_else(\n       pexp(maxtime, rate = rate) < (1 - error_tolerance), \n       pexp(maxtime, rate = rate), \n       1);\n     cumulative_dist <- c(cumulative_dist, temp_prob)\n     \n     # get current prob (pi)\n     curr_prob <- temp_prob - prev_prob\n     prob_dist <- c(prob_dist, curr_prob)\n     \n     # get current transition prob\n     curr_transprob <- curr_prob/(1-prev_prob)\n     transprob <- c(transprob, curr_transprob)\n     \n     prev_prob <- temp_prob\n     maxtime <- maxtime + timestep\n     \n     if(temp_prob == 1){\n       break\n     }\n  }\n  \n  data.frame(\n    prob_dist = prob_dist,\n    cumulative_dist = cumulative_dist,\n    transprob = transprob\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Helper function for plotting\"}\nplot_helper <- function(data){\n  data %>% ggplot() +\n  geom_line(aes(x = time, y = S, color = \"S\")) +\n  geom_line(aes(x = time, y = I, color = \"I\")) +\n  geom_line(aes(x = time, y = R, color = \"R\")) +\n  geom_line(aes(x = time, y = D, color = \"D\"), linetype = \"dashed\") +\n  scale_color_manual(\n    values = c(\"S\" = \"blueviolet\", \"I\"=\"red\", \"R\"=\"cornflowerblue\", \"D\"=\"darkgreen\")\n  ) +\n  labs(\n    x = \"Time\",\n    y = \"Number of people\"\n  )\n}\n```\n:::\n\n\n# Run model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulationDuration <- 75\ntimestep <- 0.05\n```\n:::\n\n\n## Different maximum dwell time (with normalization) {#sec-normalize}\n\nTest scenario where maximum dwell time of R\\>D, normalization applied\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model config\"}\nmod1_config <- list(\n  rate = 0.1,\n  d_rate = 0.3,\n  beta = 0.4,\n  S = 950, \n  I = 50,\n  R = 0,\n  D = 0,\n  N = 1000\n)\n```\n:::\n\n\n::: panel-tabset\n## Proposed algo\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model set up\"}\n# generate discrete dwell time distribution for I -> R\nr_dist <- compute_trans_prob(rate = mod1_config$rate, timestep = timestep)\nr_dist <- r_dist$prob_dist\n\nd_dist <- compute_trans_prob(rate = mod1_config$d_rate, timestep = timestep)\nd_dist <- d_dist$prob_dist\n\nodin_pars <- list(\n  beta =  mod1_config$beta,\n  N =  mod1_config$N,\n  r_dist = r_dist,\n  r_maxtime = length(r_dist),\n  d_dist = d_dist,\n  d_maxtime = length(d_dist),\n  S_init = mod1_config$S,\n  I_init = array( c(mod1_config$I, rep(0, length(r_dist)-1)) ),\n  R_init = mod1_config$R,\n  D_init = mod1_config$D,\n  normalize_dist=TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run odin model\"}\nsird <- dust_system_create(sird_mod, odin_pars, dt = timestep)\ndust_system_set_state_initial(sird)\n\nt_seq <- seq(0, simulationDuration, 0.25)\n\nout <- dust_system_simulate(sird, t_seq)\nout <- dust_unpack_state(sird, out)\n\nodin_result <- data.frame(\n  time = t_seq,\n  S = out$S,\n  I = colSums(out$I),\n  R = out$R,\n  D = out$D\n)\n\nplot_helper(odin_result)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## deSolve (competing risks)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * I/N\n\n    dI = beta * S * I/N - rate*I - d_rate*I\n    dR = rate*I \n    \n    # handle I -> D transition\n    dD = d_rate*I\n\n    list(c(dS, dI, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod1_config$S, \n  I = mod1_config$I,\n  R = mod1_config$R,\n  D = mod1_config$D\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod1_config$beta,\n  N = mod1_config$N,\n  rate = mod1_config$rate, # recovery rate\n  d_rate = mod1_config$d_rate # death rate\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## deSolve (multinomial)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * (IR + ID)/N\n    \n    dIR = 0.5*beta * S * (IR + ID)/N - rate*IR\n    dID = 0.5*beta * S * (IR + ID)/N - d_rate*ID\n    \n    dR = rate*IR\n    \n    # handle I -> D transition\n    dD = d_rate*ID\n\n    list(c(dS, dIR, dID, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod1_config$S, \n  IR = 0.5*mod1_config$I,\n  ID = 0.5*mod1_config$I,\n  R = 0,\n  D = 0\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod1_config$beta,\n  N = mod1_config$N,\n  rate = mod1_config$rate, # recovery rate\n  d_rate = mod1_config$d_rate, # death rate\n  r_prob = mod1_config$r_prob,\n  d_prob = mod1_config$d_prob\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod) %>% \n  mutate(I = ID + IR)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n:::\n\n## Same maximum dwell time in R and D\n\nRun model with normalizing for $b_i$, expect that this scenario to have the same output as multinomial\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model config\"}\nmod2_config <- list(\n  rate = 0.2,\n  d_rate = 0.2,\n  beta = 0.4,\n  S = 950, \n  I = 50,\n  R = 0,\n  D = 0,\n  N = 1000\n)\n```\n:::\n\n\n::: panel-tabset\n## Proposed algo\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model set up\"}\n# generate discrete dwell time distribution for I -> R\nr_dist <- compute_trans_prob(rate = mod2_config$rate, timestep = timestep)\nr_dist <- r_dist$prob_dist\n\n# generate discrete dwell time distribution for I -> D\nd_dist <- compute_trans_prob(rate = mod2_config$d_rate, timestep = timestep)\nd_dist <- d_dist$prob_dist\n\nodin_pars <- list(\n  beta = mod2_config$beta,\n  N = mod2_config$N,\n  r_dist = r_dist,\n  r_maxtime = length(r_dist),\n  d_dist = d_dist,\n  d_maxtime = length(d_dist),\n  S_init = mod2_config$S,\n  I_init = array( c(mod2_config$I, rep(0, length(r_dist)-1)) ),\n  R_init = mod2_config$R,\n  D_init = mod2_config$D\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run odin model\"}\nsird <- dust_system_create(sird_mod, odin_pars, dt = timestep)\ndust_system_set_state_initial(sird)\n\nt_seq <- seq(0, simulationDuration, 0.5)\n\nout <- dust_system_simulate(sird, t_seq)\nout <- dust_unpack_state(sird, out)\n\nodin_result <- data.frame(\n  time = t_seq,\n  S = out$S,\n  I = colSums(out$I),\n  R = out$R,\n  D = out$D\n)\n\nplot_helper(odin_result)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/run model-1.png){width=672}\n:::\n:::\n\n\n## deSolve (competitive risks)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * I/N\n    \n    dI = beta * S * I/N - rate*I - d_rate*I\n    dR = rate*I \n    \n    # handle I -> D transition\n    dD = d_rate*I\n\n    list(c(dS, dI, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod2_config$S, \n  I = mod2_config$I,\n  R = mod2_config$R,\n  D = mod2_config$D\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod2_config$beta,\n  N = mod2_config$N,\n  rate = mod2_config$rate, # recovery rate\n  d_rate = mod2_config$d_rate # death rate\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## deSolve (multinomial)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * (IR + ID)/N\n    \n    dIR = 0.5*beta * S * (IR + ID)/N - rate*IR\n    dID = 0.5*beta * S * (IR + ID)/N - d_rate*ID\n    \n    dR = rate*IR\n    \n    # handle I -> D transition\n    dD = d_rate*ID\n\n    list(c(dS, dIR, dID, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod2_config$S, \n  IR = 0.5*mod2_config$I,\n  ID = 0.5*mod2_config$I,\n  R = 0,\n  D = 0\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod2_config$beta,\n  N = mod2_config$N,\n  rate = mod2_config$rate, # recovery rate\n  d_rate = mod2_config$d_rate # death rate\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod) %>% \n  mutate(I = ID + IR)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\n## Different maximum dwell time (no normalization)  {#sec-no-normalize}\n\nTest scenario where maximum dwell time of R\\>D, normalization not applied\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model config\"}\nmod3_config <- list(\n  rate = 0.1,\n  d_rate = 0.3,\n  beta = 0.4,\n  S = 950, \n  I = 50,\n  R = 0,\n  D = 0,\n  N = 1000,\n  r_prob = 0.5,\n  d_prob = 0.5\n)\n```\n:::\n\n\n::: panel-tabset\n## Proposed algo\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model set up\"}\n# generate discrete dwell time distribution for I -> R\nr_dist <- compute_trans_prob(rate = mod3_config$rate, timestep = timestep)\nr_dist <- r_dist$prob_dist\nd_dist <- compute_trans_prob(rate = mod3_config$d_rate, timestep = timestep)\nd_dist <- d_dist$prob_dist\n\nodin_pars <- list(\n  beta =  mod3_config$beta,\n  N =  mod3_config$N,\n  r_dist = r_dist,\n  r_maxtime = length(r_dist),\n  r_prob = mod3_config$r_prob,\n  d_dist = d_dist,\n  d_maxtime = length(d_dist),\n  d_prob = mod3_config$d_prob,\n  S_init = mod3_config$S,\n  I_init = array( c(mod3_config$I, rep(0, length(r_dist)-1)) ),\n  R_init = mod3_config$R,\n  D_init = mod3_config$D,\n  normalize_dist = FALSE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run odin model\"}\nsird <- dust_system_create(sird_mod, odin_pars, dt = timestep)\ndust_system_set_state_initial(sird)\n\nt_seq <- seq(0, simulationDuration, 0.25)\n\nout <- dust_system_simulate(sird, t_seq)\nout <- dust_unpack_state(sird, out)\n\nodin_result <- data.frame(\n  time = t_seq,\n  S = out$S,\n  I = colSums(out$I),\n  R = out$R,\n  D = out$D\n)\n\nplot_helper(odin_result)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/run model (expect error)-1.png){width=672}\n:::\n:::\n\n## deSolve (competing risks)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * I/N\n\n    dI = beta * S * I/N - rate*I - d_rate*I\n    dR = rate*I \n    \n    # handle I -> D transition\n    dD = d_rate*I\n\n    list(c(dS, dI, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod3_config$S, \n  I = mod3_config$I,\n  R = mod3_config$R,\n  D = mod3_config$D\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod3_config$beta,\n  N = mod3_config$N,\n  rate = mod3_config$rate, # recovery rate\n  d_rate = mod3_config$d_rate # death rate\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## deSolve (multinomial)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Run deSolve model\"}\ntransition_func <- function(t, state, param){\n  with(as.list( c(state, param) ), {\n    dS = - beta * S * (IR + ID)/N\n    \n    dIR = r_prob*beta * S * (IR + ID)/N - rate*IR\n    dID = d_prob*beta * S * (IR + ID)/N - d_rate*ID\n    \n    dR = rate*IR\n    \n    # handle I -> D transition\n    dD = d_rate*ID\n\n    list(c(dS, dIR, dID, dR, dD))\n  })\n}\n\ndesolveInitialValues <- c(\n  S = mod3_config$S, \n  IR = mod3_config$r_prob*mod3_config$I,\n  ID = mod3_config$d_prob*mod3_config$I,\n  R = 0,\n  D = 0\n)\n\n# ====== settings ======== \nparameters <- c(\n  beta = mod3_config$beta,\n  N = mod3_config$N,\n  rate = mod3_config$rate, # recovery rate\n  d_rate = mod3_config$d_rate, # death rate\n  r_prob = mod3_config$r_prob,\n  d_prob = mod3_config$d_prob\n)\n\ntimes <- seq(0, simulationDuration)\node_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func) \node_mod <- as.data.frame(ode_mod) %>% \n  mutate(I = ID + IR)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot output\"}\nplot_helper(ode_mod)\n```\n\n::: {.cell-output-display}\n![](competing_risks_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n:::\n",
    "supporting": [
      "competing_risks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}